name: CI Pipeline  
  
on:  
  push:  
    branches:  
      - main  

  
jobs:  
  build-and-deploy:  
    runs-on: ubuntu-latest  
    env:   
      IMAGE_NAME: "testcicd"
      DOCKER_REPO: "testcicd"
      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      DOCKER_REGISTRY_URL: "http://139.159.155.126:5000"
    steps:  
      - name: Checkout Repository  
        uses: actions/checkout@v3  
  
      # 安装Node.js和npm  
      - name: Set up Node.js  
        uses: actions/setup-node@v3  
        with:  
          node-version: '22'  
  
      # 缓存node_modules以加速构建  
      - name: Cache node_modules  
        uses: actions/cache@v3  
        with:  
          path: '**/node_modules'  
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}  
          restore-keys: |  
            ${{ runner.os }}-node-  
  
      # 安装项目依赖  
      - name: Install Dependencies  
        run: npm install  

      # 运行测试（假设有test脚本）  
      #- name: Run Tests  
      #  run: npm test  
      # 确认目录下有dockerfile文件
      - name: Check for Dockerfile and create if missing
        run: |
          # 将时间戳作为环境变量设置
          TIMESTAMP=$(date +'%Y%m%d%H%M%S')
          # 检查 Dockerfile 是否存在
          if [ ! -f "Dockerfile" ]; then
            echo "Dockerfile not found, creating a default one for a Node.js project..."
            echo "FROM node:22" > Dockerfile
            echo "WORKDIR /usr/src/app" >> Dockerfile
            echo "COPY package*.json ./" >> Dockerfile
            echo "RUN npm install" >> Dockerfile
            echo "COPY . ." >> Dockerfile
            echo "EXPOSE 8080" >> Dockerfile
            echo 'CMD ["npm", "test"]' >> Dockerfile
          else
            echo "Dockerfile found, using existing one."
          fi
 # 构建Docker镜像
      - name: Build Docker Image
        id: build-image
        run: |
          TIMESTAMP=$(date +'%Y%m%d%H%M%S')
          docker build -t ${IMAGE_NAME}:${TIMESTAMP} .
          echo "::set-output name=timestamp::${TIMESTAMP}"
        env:
          IMAGE_NAME: ${{ env.IMAGE_NAME }}

      # 手动设置Docker配置文件
      - name: Configure Docker Credentials
        run: |
          # 创建临时目录用于存放认证信息
          mkdir -p ~/.docker
          # 使用环境变量中的用户名和密码创建一个Docker配置文件
          echo "{\"auths\":{\"http://${{ env.DOCKER_REGISTRY_URL }}\":{\"username\":\"${{ secrets.DOCKER_USERNAME }}\",\"password\":\"${{ secrets.DOCKER_PASSWORD }}\"}}}" > ~/.docker/config.json
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}

      # 标记Docker镜像
      - name: Tag Docker Image
        run: |
          TIMESTAMP=${{ steps.build-image.outputs.timestamp }}
          REGISTRY_PATH=http://139.159.155.126:5000
          docker tag ${IMAGE_NAME}:${TIMESTAMP} ${REGISTRY_PATH}/${DOCKER_REPO}:${TIMESTAMP}
        env:
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          DOCKER_REPO: ${{ env.DOCKER_REPO }}

      # 推送Docker镜像到Docker Registry
      - name: Push Docker Image to Docker Registry
        run: |
          TIMESTAMP=${{ steps.build-image.outputs.timestamp }}
          REGISTRY_PATH=http://139.159.155.126:5000
          docker push ${REGISTRY_PATH}/${DOCKER_REPO}:${TIMESTAMP}
        env:
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          DOCKER_REPO: ${{ env.DOCKER_REPO }}

      # 可选：推送带有latest标签的镜像
      - name: Push Docker Image with latest tag (optional)
        run: |
          TIMESTAMP=${{ steps.build-image.outputs.timestamp }}
          REGISTRY_PATH=http://139.159.155.126:5000
          docker tag ${IMAGE_NAME}:${TIMESTAMP} ${REGISTRY_PATH}/${DOCKER_REPO}:latest
          docker push ${REGISTRY_PATH}/${DOCKER_REPO}:latest
        env:
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          DOCKER_REPO: ${{ env.DOCKER_REPO }}

      # 通知（可选，例如使用Slack等通知工具）
      - name: Notify Server with Latest Docker Image Name
        run: |
          TIMESTAMP=${{ steps.build-image.outputs.timestamp }}
          REGISTRY_PATH=http://139.159.155.126:5000
          image_name="${REGISTRY_PATH}/${DOCKER_REPO}:${TIMESTAMP}"
          json_payload='{
            "image_name": "'"$image_name'""
          }'
          curl -X POST -H "Content-Type: application/json" --data "$json_payload" ${{ secrets.WEBHOOK_URL }}
        env:
          DOCKER_REPO: ${{ env.DOCKER_REPO }}
