name: CI Pipeline  
  
on:  
  push:  
    branches:  
      - main  

  
jobs:  
  build-and-deploy:  
    runs-on: ubuntu-latest  
    env:   
      IMAGE_NAME: "testcicd"  
      DOCKER_REPO: "testcicd"   
      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}  
  
    steps:  
      - name: Checkout Repository  
        uses: actions/checkout@v3  
  
      # 安装Node.js和npm  
      - name: Set up Node.js  
        uses: actions/setup-node@v3  
        with:  
          node-version: '22'  
  
      # 缓存node_modules以加速构建  
      - name: Cache node_modules  
        uses: actions/cache@v3  
        with:  
          path: '**/node_modules'  
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}  
          restore-keys: |  
            ${{ runner.os }}-node-  
  
      # 安装项目依赖  
      - name: Install Dependencies  
        run: npm install  

      # 运行测试（假设有test脚本）  
      #- name: Run Tests  
      #  run: npm test  
      # 确认目录下有dockerfile文件
      - name: Check for Dockerfile and create if missing
        run: |
          # 将时间戳作为环境变量设置
          TIMESTAMP=$(date +'%Y%m%d%H%M%S')
          # 检查 Dockerfile 是否存在
          if [ ! -f "Dockerfile" ]; then
            echo "Dockerfile not found, creating a default one for a Node.js project..."
            echo "FROM node:22" > Dockerfile
            echo "WORKDIR /usr/src/app" >> Dockerfile
            echo "COPY package*.json ./" >> Dockerfile
            echo "RUN npm install" >> Dockerfile
            echo "COPY . ." >> Dockerfile
            echo "EXPOSE 8080" >> Dockerfile
            echo 'CMD ["npm", "test"]' >> Dockerfile
          else
            echo "Dockerfile found, using existing one."
          fi
      # 构建Docker镜像  
      - name: Build Docker Image  
        run: |  
          TIMESTAMP=$(date +'%Y%m%d%H%M%S')  
          docker build -t ${IMAGE_NAME}:${TIMESTAMP} .  
        env:  
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          
     # 使用curl模拟登录并获取认证令牌
      - name: Simulate Login to private Docker registry
        run: |
          # 创建临时目录用于存放认证信息
          mkdir -p ~/.docker
          # 使用curl命令发送认证请求
          AUTH_TOKEN=$(echo -n "${{ secrets.DOCKER_USERNAME }}:${{ secrets.DOCKER_PASSWORD }}" | base64)
          # 将认证信息写入配置文件
          echo "{\"auths\":{\"${{ env.DOCKER_REGISTRY_URL }}\":{\"username\":\"${{ secrets.DOCKER_USERNAME }}\",\"password\":\"${{ secrets.DOCKER_PASSWORD }}\"}}}" > ~/.docker/config.json
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}

      # 推送Docker镜像到Docker Registry
      - name: Push Docker Image to Docker Registry
        run: |
          TIMESTAMP=$(date +'%Y%m%d%H%M%S')
          docker tag ${IMAGE_NAME}:${TIMESTAMP} ${DOCKER_REPO}:${TIMESTAMP}
          # 使用已设置的配置文件进行推送
          docker push ${DOCKER_REPO}:${TIMESTAMP}
        env:
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          DOCKER_REPO: ${{ env.DOCKER_REPO }}

      # 可选：推送带有latest标签的镜像
      - name: Push Docker Image with latest tag (optional)
        run: |
          TIMESTAMP=$(date +'%Y%m%d%H%M%S')
          docker tag ${IMAGE_NAME}:${TIMESTAMP} ${DOCKER_REPO}:latest
          docker push ${DOCKER_REPO}:latest
        env:
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          DOCKER_REPO: ${{ env.DOCKER_REPO }}

      # 通知（可选，例如使用Slack等通知工具）
      - name: Notify Server with Latest Docker Image Name
        run: |
          TIMESTAMP=$(date +'%Y%m%d%H%M%S')
          image_name="${IMAGE_NAME}:${TIMESTAMP}"
          json_payload='{
            "image_name": "'"$image_name'""
          }'
          curl -X POST -H "Content-Type: application/json" --data "$json_payload" ${{ secrets.WEBHOOK_URL }}
        env:
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
